1、什么是管道？

2、回顾一下异常的信号机制？？？

3、refresh函数没有像书本那样，注释掉依然可以显示结果。

4、按照书本的代码发现P219实现，发现仍然阻塞在等待函数那里，加上O_NONBLOCK之后就可以实现了。问题就是，调试了一下代码，为什么阻塞在等待函数那里呢？按道理不应该。反向推测，sigio收到了信号，所以进入了函数。问题是为什么收到信号呢？（再简单验证一下)

做了一下实验，发现还是会阻塞，但是，第一次怎么会进入on_input里面呢？SIG_IO这个信号是在什么情况下接受信号进行处理的呢？不懂

现在的问题是：为什么第一次会进入到那个信号？也就是sigio的信号是在什么情况下进行接收的？？？

现在总结一下：

1. 在定时信号的函数没有内容，没有O_NONBLOCK的情况下：

   回车也会被记录到getchar里面，但是会阻塞在getchar那里（仔细想想，其实是阻塞在pause那里），去掉sleep有的时候就会进入main函数。（即输入u+回车进入到定时信号函数里面两次，之后进入main函数parse里面，再次输入q+回车，还是没有退出，但是再次输入别的内容就退出，而且在终端显示这些字符，表明已经退出了，但为什么还停留在程序里面？）

2. printf居然会影响sigio信号。这个需要注意一下。如果在定时信号那里sleep，那么将不会触发return，因为之前test过。

3. 打开O_NONBLOCK的时候，效果跟没有的是一样的。也就是说，在使用curose库的时候，可能会影响sigio这个信号，所以加上O_NONBLOCK的时候就会忽略没有结果的内容，达到使用目的。

4. 也就是说，正常情况下在pause那里，输入字符就相应sigio信号，但是有个问题，输入q的时候，为什么不直接退出，而是要继续输入才可以呢？

5、回去看看程序是怎么运行的。

6、fork到底发生什么？这个问题需要深入了解一下。