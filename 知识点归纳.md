1、文件/dev/tty是键盘和显示器的文件描述符，向这个文件写相当于显示在屏幕上，读相当于从键盘获取用户的输入。

2、搜索某个变量在哪个头文件的时候，可以使用以下命令：

```
grep -n -R 'UTMP_FILE' /usr/include
grep -n -R '#define.*UTMP_FILE' /usr/include
```

3、如何找相关信息：

![1563766136876](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1563766136876.png)

4、man详解

![1563767570951](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1563767570951.png)

5、可以使用man -k keyword | grep 筛选条件   这样的形式去查找手册里面的联机帮助。

6、磁盘是如何存储数据的？

![1564111409068](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1564111409068.png)

过程如下：

![1564111448455](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1564111448455.png)

7、按照书本字面上的理解，磁盘块上的结构是一样的，都是如下：

![1564123037536](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1564123037536.png)

磁盘块可以和扇区大小一样，也可以不一样。

8、在Linux中，文件是一个i-结点和一些数据块的结合，链接是对i-结点的引用，因此，所谓的文件名，不是真正的文件名，文件没有文件名，其实是链接的名字。

9、如此不难理解，readdir返回的结构中包含的内容，大致是i-node链接和文件名。stat是通过i-node找到文件信息并填充stat结构返回。

10、设备文件的i结点存储的是指向内核子程序的指针，内核中，传输设备数据的子程序被称为设备驱动程序。

11、内核处理终端数据：

![1564563151202](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1564563151202.png)

![1564563392465](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1564563392465.png)

12、信号：

![1566806534164](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1566806534164.png)

13、搞清楚一些细节方面的东西：

![1566808799838](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1566808799838.png)

上图可以知道，通过ioctl可以对其他任何设备进行编程，而tcgetattr和tcsetattr只是针对终端的。

14、Linux的信号机制：

<https://www.cnblogs.com/hoys/archive/2012/08/19/2646377.html>

15、编写程序的时候，遇到没有curses.h这个文件的时候如下做法：

yum install ncurses-libs
yum install ncurses-devel

16、sleep函数是调用alarm实现的。

17、计算机有几个时钟？

一个系统只需要一个时钟来设置节拍，一个硬件时钟的脉冲是计算机里唯一需要的时钟，每个进程设置自己的计数时间，操作系统在每过一个时间片后为所有的计数器数值做递减。

![1567495914560](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1567495914560.png)

![1567495943919](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1567495943919.png)

18、测试所用的系统一些特性

1. 调用后还起作用（也就是不是捕鼠器模型）
2. x信号被y信号打断跳到y信号的处理函数执行
3. 第二个相同的信号过来第二个信号被阻塞直到第一个信号被处理完。（有可能丢失信号）
4. 程序在等待的时候接受信号，这时候会抛弃前面的字符，重新接受。
5. 接受信号进行处理的时候，如果这个时候有输入，则有时候会丢失，也有可能阻塞后接受输入字符。

19、使用sio_read的时候，编译的时候使用-lrt,同时，如果想多次使用aio_read，要写多次，不可以只写一次。

20、操作系统内核是要异步输入（回顾一下中断的三种方式，其中的第二种），内核的异步输入是由软件实现的

![1568084141779](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1568084141779.png)

21、一共有五种IO模型，分别是阻塞IO模型，非阻塞IO模型，IO复用模型，信号驱动IO模型，异步IO模型。其中，前面四种是同步IO，只有后面那种才是真正的异步IO。区别于同步与异步的根本区别是数据从内核到用户态进程是否有阻塞，只有异步IO模型才是完全没有阻塞的，即只有他才是真正的异步。	

22、按照书本上的说法，shell是如何运行程序的？

![1568168847891](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1568168847891.png)

也就是shell建立一个新进程，在那个进程里将程序载入直到运行结束。而execvp则是在当前进程里载入程序代替当前的数据和代码。

23、exec会把当前进程的机器指令清除。

![1568170093247](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1568170093247.png)

24、unix里面的shell模型如下图：

![1568601926943](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1568601926943.png)

25、键盘的信号发送给所有连接的进程。所以最初的时候shell模型如果在等待子进程执行的时候键盘按下ctrl-c的时候就会导致shell也会退出。

26、zombie：僵尸进程：根据文档描述如下：

If the parent has not indicated that it is not interested in the exit status, but is not waiting, the exiting process turns into a "zombie" process (which is nothing but  a container for the single byte representing the exit status) so that the parent can learn the exit status when it later calls one of the wait(2) functions.

僵尸进程只是包含退出状态，但是仍然占据着进程id，所以过多的僵尸进程会导致无法创建进程。当父进程结束之后，僵尸进程变成孤儿进程，由init进程销毁。

孤儿进程：父进程结束，子进程还没有结束。

27、unix/Linux里面的程序都遵循以0退出表明成功的惯例。

28、在调用exec相关的函数的时候，environ将指针和指向的数组会复制到新的程序的数据空间。

29、什么是环境？

![1568949289070](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1568949289070.png)

30、gch文件是预编译头，就是把头文件事先翻译成一种二进制的格式，供后续的编译过程使用。